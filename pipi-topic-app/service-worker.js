async function アクティベート(event){}
function メッセージ受信(event){if(event.data==="updateNotificationTime"){startNotificationTimer()}}
const SERVICEWORKER_SETTING={DB_NAME:"pipi-topic-db",DB_VERSION:1,APP_SETTING_STORE_NAME:"settings",TOPICS_STORE_NAME:"topics",NOTIFICATION_TIME_STORE_NAME:'notificationTimes',}
async function プッシュ受信(event){event.waitUntil((async()=>{const pushEvent=event;const json=await event.data.json();const topics=JSON.parse(json.data.topics);const options=json.notification;let db=null;try{db=await svOpenDB();const formatter=new Intl.DateTimeFormat('ja-JP',{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',timeZone:'Asia/Tokyo',});for(const topic of topics){let saveTopic={};if(topic.topicNo!=="test"){saveTopic={topicNo:topic.topicNo,keywords:topic.keywords,timestamp:formatter.format(new Date()),}}
await svPutStoreValue(db,SERVICEWORKER_SETTING.TOPICS_STORE_NAME,saveTopic)}
await startNotificationTimer()}catch(error){console.error('プッシュ受信処理でエラーが発生しました:',error)}finally{if(db)await svCloseDB(db);}})())}
async function executeNotification(){let db=null;try{db=await svOpenDB();const dbTopics=await svGetAllStoreValue(db,SERVICEWORKER_SETTING.TOPICS_STORE_NAME);const keywords=dbTopics.flatMap(topic=>topic.keywords);const uniqueKeywords=Array.from(new Set(keywords));if(uniqueKeywords.length>0){const options={title:"新しい記事があります",body:`" ${uniqueKeywords.join(", ")} " に一致する新しい記事があります。アプリで確認してください。`,icon:"./images/icon-192x192.png"};return self.registration.showNotification(options.title,options)}}catch(error){console.error('通知処理でエラーが発生しました:',error)}finally{if(db)await svCloseDB(db);}}
function calculateNextNotificationTime(notificationTimes){const now=new Date();const nowTime=now.getTime();let closestTime=null;let minDiff=Infinity;for(const timeObj of notificationTimes){const timeStr=timeObj.time;const[hours,minutes]=timeStr.split(':').map(Number);const notificationTime=new Date(now.getFullYear(),now.getMonth(),now.getDate(),hours,minutes,0,0);if(notificationTime.getTime()<nowTime){notificationTime.setDate(notificationTime.getDate()+1)}
const diff=notificationTime.getTime()-nowTime;if(diff<minDiff){minDiff=diff;closestTime=notificationTime}}
return{closestTime,minDiff}}
async function startNotificationTimer(){let db=null;try{db=await svOpenDB();let notificationTimerId=(await svGetStoreValue(db,SERVICEWORKER_SETTING.APP_SETTING_STORE_NAME,"notificationTimerId"))?.value||null;if(notificationTimerId){clearTimeout(notificationTimerId)}
const notificationTimes=await svGetAllStoreValue(db,SERVICEWORKER_SETTING.NOTIFICATION_TIME_STORE_NAME);if(notificationTimes&&notificationTimes.length>0){const{closestTime,minDiff}=calculateNextNotificationTime(notificationTimes);if(closestTime){notificationTimerId=setTimeout(async()=>{await executeNotification();await startNotificationTimer()},minDiff);await svPutStoreValue(db,SERVICEWORKER_SETTING.APP_SETTING_STORE_NAME,{key:"notificationTimerId",value:Number(notificationTimerId)});await svPutStoreValue(db,SERVICEWORKER_SETTING.APP_SETTING_STORE_NAME,{key:"nextNotificationTime",value:closestTime});console.log('次の通知時刻:',closestTime,'タイマーセット:',minDiff)}}}catch(error){console.error('タイマーセット処理でエラーが発生しました:',error)}finally{if(db)await svCloseDB(db);}}
async function svOpenDB(){return new Promise((resolve,reject)=>{const request=indexedDB.open(SERVICEWORKER_SETTING.DB_NAME,SERVICEWORKER_SETTING.DB_VERSION);request.onerror=(event)=>{reject(event)};request.onsuccess=(event)=>{resolve(event.target.result)}})}
async function svPutStoreValue(db,storeName,value){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readwrite');const store=tx.objectStore(storeName);const request=store.put(value);request.onsuccess=(event)=>{resolve(event.target.result)};request.onerror=(event)=>{reject(event.target.error)};tx.oncomplete=()=>{};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function svGetStoreValue(db,storeName,key){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readonly');const store=tx.objectStore(storeName);const request=store.get(key);request.onsuccess=(event)=>{resolve(event.target.result)};request.onerror=(event)=>{reject(event.target.error)};tx.oncomplete=()=>{};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function svGetAllStoreValue(db,storeName){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readonly');const store=tx.objectStore(storeName);const request=store.getAll();request.onsuccess=(event)=>{resolve(event.target.result)};request.onerror=(event)=>{reject(event.target.error)};tx.oncomplete=()=>{};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function svDeleteStoreValue(db,storeName,key){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readwrite');const store=tx.objectStore(storeName);const request=store.delete(key);request.onsuccess=(event)=>{resolve(event.target.result)};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function svDeleteIndexedDB(dbName){return new Promise((resolve,reject)=>{const request=indexedDB.deleteDatabase(dbName);request.onsuccess=()=>{console.log("IndexedDB deleted successfully.");resolve()};request.onerror=(event)=>{console.error("Error deleting IndexedDB:",event.target.error);reject(event.target.error)}})}
async function svCloseDB(db){return new Promise((resolve,reject)=>{db.close();resolve()})}
function プッシュ通知クリック(event){event.notification.close();event.waitUntil(clients.matchAll({type:'window',includeUncontrolled:!0}).then(function(clientList){debugger
for(var i=0;i<clientList.length;i++){var client=clientList[i];if(client.url==='https://dev.pwappy.com/i0iv7dv/pipi-topic-app/1.0.0/'&&'focus' in client)
return client.focus();if(client.url==='https://pwappy-com.github.io/example-apps/pipi-topic-app/'&&'focus' in client)
return client.focus();}
return clients.openWindow('https://pwappy-com.github.io/example-apps/pipi-topic-app/')}))}
self.addEventListener("activate",(event)=>{アクティベート(event)});self.addEventListener("message",(event)=>{メッセージ受信(event)});self.addEventListener("push",(event)=>{プッシュ受信(event)});self.addEventListener("notificationclick",(event)=>{プッシュ通知クリック(event)})