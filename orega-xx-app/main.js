import vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";const{FaceLandmarker,FilesetResolver,DrawingUtils}=vision;function 撮影ページ初期化(event){const page=event.target;const onsModalSatuei=document.getElementById('ons-modal-satuei');const onsPagePhoto=document.getElementById('ons-page-photo');const onsButtonCameraRotate=document.getElementById('ons-button-camera-rotate');const onsButtonCameraExec=document.getElementById('ons-button-camera-exec');const onsButtonMask=document.getElementById('ons-button-mask');const onsButtonComp=document.getElementById('ons-button-comp');const onsButtonMovieExec=document.getElementById('ons-button-movie-exec');const spanProcessingMessage=document.getElementById('span-processing-message');const potoData=event?.target?.data?.photo;const overlayImage=document.getElementById('overlay-image');let overlayImageAspectRatio=1;if(potoData){overlayImage.src=potoData;overlayImage.onload=()=>{overlayImageAspectRatio=overlayImage.naturalWidth/overlayImage.naturalHeight}}
const demosSection=document.getElementById("demos");const videoBlendShapes=document.getElementById("video-blend-shapes");const errorMessageDiv=document.getElementById('error-message');let faceLandmarker;let runningMode="VIDEO";let enableWebcamButton;let webcamRunning=!1;let stream=null;const videoWidth=480;let facingMode="user";let initialTouchX=0;let initialTouchY=0;let offsetX=0;let offsetY=0;let initialPinchDistance=0;let currentScale=1.0;let isDragging=!1;let isPinching=!1;let rectInitialTouchX=0;let rectInitialTouchY=0;let rectOffsetX=0;let rectOffsetY=0;let rectInitialPinchDistance=0;let rectCurrentScale=1.0;let isRectDragging=!1;let isRectPinching=!1;let maskEnabled=!1;let compEnabled=!1;let rectX=0;let rectY=0;let rectWidth=0;let rectHeight=0;let roll=0;let yaw=0;onsButtonCameraRotate.addEventListener('click',cameraRotate);async function cameraRotate(event){facingMode=facingMode==="user"?"environment":"user";await stopCamera();faceLandmarker=null;await createFaceLandmarker();await enableCam()}
onsPagePhoto.addEventListener('show',showPage);async function showPage(event){onsModalSatuei.show();try{await createFaceLandmarker();await enableCam()}finally{onsModalSatuei.hide()}}
onsPagePhoto.addEventListener('hide',hidePage);function hidePage(event){stopCamera()}
async function createFaceLandmarker(){try{const filesetResolver=await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");faceLandmarker=await FaceLandmarker.createFromOptions(filesetResolver,{baseOptions:{modelAssetPath:`https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,delegate:"GPU",},outputFaceBlendshapes:!0,runningMode,numFaces:1,});demosSection.classList.remove("invisible")}catch(error){displayError(`Failed to create FaceLandmarker: ${error}`)}}
const video=document.getElementById("webcam");const canvasElement=document.getElementById("output_canvas");const canvasCtx=canvasElement.getContext("2d");function hasGetUserMedia(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}
if(hasGetUserMedia()){enableWebcamButton=document.getElementById("webcamButton");enableWebcamButton.addEventListener("click",enableCam)}else{displayError("getUserMedia() is not supported by your browser")}
async function enableCam(event){if(!faceLandmarker){displayError("Wait! faceLandmarker not loaded yet.");return}
if(webcamRunning===!0){webcamRunning=!1;enableWebcamButton.innerText="ENABLE PREDICTIONS"}else{webcamRunning=!0;enableWebcamButton.innerText="DISABLE PREDICTIONS"}
const constraints={video:{facingMode:facingMode,advanced:[{width:4096,height:2160},{width:1920,height:1080},{width:1280,height:720},{width:640,height:480},{},],},audio:!1,};try{if(stream){video.removeEventListener('loadeddata',predictWebcam);stream.getTracks().forEach(track=>track.stop());video.srcObject=null}
canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);stream=await navigator.mediaDevices.getUserMedia(constraints);video.srcObject=stream;video.play();video.addEventListener("loadeddata",predictWebcam)}catch(error){displayError(`Failed to access webcam: ${error}`)}}
async function stopCamera(){if(stream){stream.getTracks().forEach(track=>track.stop());video.srcObject=null}}
canvasElement.addEventListener('touchstart',(event)=>{if(maskEnabled){if(event.touches.length===1){isDragging=!0;initialTouchX=event.touches[0].clientX;initialTouchY=event.touches[0].clientY}else if(event.touches.length===2){isPinching=!0;initialPinchDistance=Math.hypot(event.touches[0].clientX-event.touches[1].clientX,event.touches[0].clientY-event.touches[1].clientY)}}
if(compEnabled){if(event.touches.length===1){isRectDragging=!0;rectInitialTouchX=event.touches[0].clientX;rectInitialTouchY=event.touches[0].clientY}else if(event.touches.length===2){isRectPinching=!0;rectInitialPinchDistance=Math.hypot(event.touches[0].clientX-event.touches[1].clientX,event.touches[0].clientY-event.touches[1].clientY)}}});canvasElement.addEventListener('touchmove',(event)=>{if(isDragging&&event.touches.length===1&&maskEnabled){const touchX=event.touches[0].clientX;const touchY=event.touches[0].clientY;offsetX+=-(touchX-initialTouchX);offsetY+=(touchY-initialTouchY);initialTouchX=touchX;initialTouchY=touchY}else if(isPinching&&event.touches.length===2&&maskEnabled){const pinchDistance=Math.hypot(event.touches[0].clientX-event.touches[1].clientX,event.touches[0].clientY-event.touches[1].clientY);currentScale*=pinchDistance/initialPinchDistance;initialPinchDistance=pinchDistance}
if(isRectDragging&&event.touches.length===1&&compEnabled){const touchX=event.touches[0].clientX;const touchY=event.touches[0].clientY;rectOffsetX+=-(touchX-rectInitialTouchX);rectOffsetY+=(touchY-rectInitialTouchY);rectInitialTouchX=touchX;rectInitialTouchY=touchY}else if(isRectPinching&&event.touches.length===2&&compEnabled){const pinchDistance=Math.hypot(event.touches[0].clientX-event.touches[1].clientX,event.touches[0].clientY-event.touches[1].clientY);rectCurrentScale*=pinchDistance/rectInitialPinchDistance;rectInitialPinchDistance=pinchDistance}});canvasElement.addEventListener('touchend',(event)=>{isDragging=!1;isPinching=!1;isRectDragging=!1;isRectPinching=!1});let lastVideoTime=-1;let results=undefined;async function predictWebcam(){try{canvasElement.width=video.videoWidth;canvasElement.height=video.videoHeight;if(runningMode==="IMAGE"){runningMode="VIDEO";await faceLandmarker.setOptions({runningMode:runningMode})}
let startTimeMs=performance.now();if(lastVideoTime!==video.currentTime){lastVideoTime=video.currentTime;results=faceLandmarker.detectForVideo(video,startTimeMs)}
canvasCtx.clearRect(0,0,canvasElement.width,canvasElement.height);canvasCtx.save();canvasCtx.translate(canvasElement.width,0);canvasCtx.scale(-1,1);const sx=0;const sy=0;const sWidth=video.videoWidth;const sHeight=video.videoHeight;const dx=0;const dy=0;const dWidth=canvasElement.width;const dHeight=canvasElement.height;canvasCtx.drawImage(video,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight);canvasCtx.restore();if(results&&results.faceLandmarks){canvasCtx.save();canvasCtx.scale(-1,1)
canvasCtx.translate(-canvasElement.width,0)
for(const landmarks of results.faceLandmarks){const faceOvalIndices=FaceLandmarker.FACE_LANDMARKS_FACE_OVAL;if(faceOvalIndices.length>0){let minX=Infinity;let minY=Infinity;let maxX=-Infinity;let maxY=-Infinity;for(const{start,end}of faceOvalIndices){for(let i=start;i<=end;i++){const point=landmarks[i];minX=Math.min(minX,point.x);minY=Math.min(minY,point.y);maxX=Math.max(maxX,point.x);maxY=Math.max(maxY,point.y)}}
let topLeft={x:minX,y:minY};let bottomRight={x:maxX,y:maxY};topLeft.x=topLeft.x*canvasElement.width;topLeft.y=topLeft.y*canvasElement.height;bottomRight.x=bottomRight.x*canvasElement.width;bottomRight.y=bottomRight.y*canvasElement.height;const faceWidth=bottomRight.x-topLeft.x;const faceHeight=bottomRight.y-topLeft.y;if(topLeft.x!==Infinity&&topLeft.y!==Infinity&&bottomRight.x!==-Infinity&&bottomRight.y!==-Infinity&&faceWidth>0&&faceHeight>0){const leftEar=landmarks[127];const rightEar=landmarks[356];const leftEye=landmarks[133];const rightEye=landmarks[362];const nose=landmarks[4];const forehead=landmarks[10];const midNoseForeheadY=(forehead.y*canvasElement.height+nose.y*canvasElement.height)/2;const dxRoll=rightEar.x-leftEar.x;const dyRoll=rightEar.y-leftEar.y;roll=Math.atan2(dyRoll,dxRoll);const rollDegree=roll*(180/Math.PI);const dxYaw=(leftEar.x+rightEar.x)/2-nose.x;yaw=Math.atan2(dxYaw,1);const yawDegree=yaw*(180/Math.PI);rectHeight=Math.abs(midNoseForeheadY-(nose.y*canvasElement.height));if(Math.abs(yawDegree)<30){rectWidth=Math.abs((rightEar.x*canvasElement.width)-(leftEar.x*canvasElement.width))}else{rectWidth=Math.abs((rightEye.x*canvasElement.width)-(leftEye.x*canvasElement.width))*1.3}
const yawFactor=1+Math.abs(yawDegree/90);rectWidth*=yawFactor;const eyesCenterX=((leftEye.x*canvasElement.width)+(rightEye.x*canvasElement.width))/2;const eyesCenterY=((leftEye.y*canvasElement.height)+(rightEye.y*canvasElement.height))/2;rectX=eyesCenterX-(rectWidth/2);rectY=eyesCenterY-rectHeight/2;const centerX=topLeft.x+faceWidth/2;const centerY=topLeft.y+faceHeight/2;const noseX=nose.x*canvasElement.width;const noseY=nose.y*canvasElement.height;const baseScale=1.0;const depthScale=baseScale
let imageWidth,imageHeight;if(faceWidth/faceHeight>overlayImageAspectRatio){imageHeight=faceHeight*1.3;imageWidth=imageHeight*overlayImageAspectRatio}else{imageWidth=faceWidth*1.3;imageHeight=imageWidth/overlayImageAspectRatio}
canvasCtx.save();canvasCtx.translate(noseX+offsetX,noseY+offsetY);canvasCtx.rotate(roll);canvasCtx.scale(-1,1);canvasCtx.transform(Math.cos(yaw),Math.sin(yaw),0,1,0,0);canvasCtx.drawImage(overlayImage,-imageWidth/2*depthScale*currentScale,-imageHeight/2*depthScale*currentScale,imageWidth*depthScale*currentScale,imageHeight*depthScale*currentScale);canvasCtx.restore();if(compEnabled){canvasCtx.save();canvasCtx.translate(rectX+rectWidth/2+rectOffsetX,rectY+rectHeight/2+rectOffsetY);canvasCtx.rotate(roll);canvasCtx.scale(rectCurrentScale,rectCurrentScale)
canvasCtx.fillStyle='black';canvasCtx.fillRect(-rectWidth/2,-rectHeight/2,rectWidth,rectHeight);canvasCtx.restore()}}else{displayError('Invalid coordinates for image drawing.')}}}
canvasCtx.restore()}}catch(error){displayError(`Error during prediction: ${error}`)}
if(webcamRunning===!0){window.requestAnimationFrame(predictWebcam)}}
function displayError(message){errorMessageDiv.textContent=message;errorMessageDiv.style.display='block';console.error(message)}
onsButtonMask.addEventListener('click',()=>{maskEnabled=!maskEnabled;onsButtonMask.style.backgroundColor=maskEnabled?"red":"";const spanPrintSwipeMessage1=document.getElementById('span-print-swipe-message1');const spanPrintSwipeMessage2=document.getElementById('span-print-swipe-message2');if(maskEnabled){spanPrintSwipeMessage1.style.display="flex";spanPrintSwipeMessage2.style.display="flex"}else{spanPrintSwipeMessage1.style.display="none";spanPrintSwipeMessage2.style.display="none"}});onsButtonComp.addEventListener('click',()=>{compEnabled=!compEnabled;onsButtonComp.style.backgroundColor=compEnabled?"red":""});onsButtonCameraExec.addEventListener('click',async function(){if(!video||!video.videoWidth||!video.videoHeight){displayError("カメラが有効になっていません。");return}
ons.notification.toast('ダウンロードが終わるまでそのままお待ち下さい',{timeout:2000,animation:"fall"});const cameraWidth=video.videoWidth;const cameraHeight=video.videoHeight;canvasElement.width=cameraWidth;canvasElement.height=cameraHeight;const tempCanvas=document.createElement('canvas');const tempCtx=tempCanvas.getContext('2d');tempCanvas.width=cameraWidth;tempCanvas.height=cameraHeight;tempCtx.save();tempCtx.translate(tempCanvas.width,0);tempCtx.scale(-1,1);tempCtx.drawImage(video,0,0,cameraWidth,cameraHeight);tempCtx.restore();if(results&&results.faceLandmarks){tempCtx.save();tempCtx.scale(-1,1)
tempCtx.translate(-tempCanvas.width,0)
for(const landmarks of results.faceLandmarks){const faceOvalIndices=FaceLandmarker.FACE_LANDMARKS_FACE_OVAL;if(faceOvalIndices.length>0){let minX=Infinity;let minY=Infinity;let maxX=-Infinity;let maxY=-Infinity;for(const{start,end}of faceOvalIndices){for(let i=start;i<=end;i++){const point=landmarks[i];minX=Math.min(minX,point.x);minY=Math.min(minY,point.y);maxX=Math.max(maxX,point.x);maxY=Math.max(maxY,point.y)}}
let topLeft={x:minX,y:minY};let bottomRight={x:maxX,y:maxY};topLeft.x=topLeft.x*cameraWidth;topLeft.y=topLeft.y*cameraHeight;bottomRight.x=bottomRight.x*cameraWidth;bottomRight.y=bottomRight.y*cameraHeight;const faceWidth=bottomRight.x-topLeft.x;const faceHeight=bottomRight.y-topLeft.y;if(topLeft.x!==Infinity&&topLeft.y!==Infinity&&bottomRight.x!==-Infinity&&bottomRight.y!==-Infinity&&faceWidth>0&&faceHeight>0){const leftEar=landmarks[127];const rightEar=landmarks[356];const leftEye=landmarks[133];const rightEye=landmarks[362];const nose=landmarks[4];const forehead=landmarks[10];const midNoseForeheadY=(forehead.y*cameraHeight+nose.y*cameraHeight)/2;const dxRoll=rightEar.x-leftEar.x;const dyRoll=rightEar.y-leftEar.y;const roll=Math.atan2(dyRoll,dxRoll);const rollDegree=roll*(180/Math.PI);const dxYaw=(leftEar.x+rightEar.x)/2-nose.x;const yaw=Math.atan2(dxYaw,1);const yawDegree=yaw*(180/Math.PI);const rectHeight=Math.abs(midNoseForeheadY-(nose.y*cameraHeight));let rectWidth;if(Math.abs(yawDegree)<30){rectWidth=Math.abs((rightEar.x*cameraWidth)-(leftEar.x*cameraWidth))}else{rectWidth=Math.abs((rightEye.x*cameraWidth)-(leftEye.x*cameraWidth))*1.3}
const yawFactor=1+Math.abs(yawDegree/90);rectWidth*=yawFactor;const eyesCenterX=((leftEye.x*cameraWidth)+(rightEye.x*cameraWidth))/2;const eyesCenterY=((leftEye.y*cameraHeight)+(rightEye.y*cameraHeight))/2;const rectX=eyesCenterX-(rectWidth/2);const rectY=eyesCenterY-rectHeight/2;const centerX=topLeft.x+faceWidth/2;const centerY=topLeft.y+faceHeight/2;const noseX=nose.x*cameraWidth;const noseY=nose.y*cameraHeight;const baseScale=1.0;const depthScale=baseScale
let imageWidth,imageHeight;if(faceWidth/faceHeight>overlayImageAspectRatio){imageHeight=faceHeight*1.3;imageWidth=imageHeight*overlayImageAspectRatio}else{imageWidth=faceWidth*1.3;imageHeight=imageWidth/overlayImageAspectRatio}
tempCtx.save();tempCtx.translate(noseX+offsetX,noseY+offsetY);tempCtx.rotate(roll);tempCtx.scale(-1,1);tempCtx.transform(Math.cos(yaw),Math.sin(yaw),0,1,0,0);tempCtx.drawImage(overlayImage,-imageWidth/2*depthScale*currentScale,-imageHeight/2*depthScale*currentScale,imageWidth*depthScale*currentScale,imageHeight*depthScale*currentScale);tempCtx.restore();if(compEnabled){tempCtx.save();tempCtx.translate(rectX+rectWidth/2+rectOffsetX,rectY+rectHeight/2+rectOffsetY);tempCtx.rotate(roll);tempCtx.scale(rectCurrentScale,rectCurrentScale)
tempCtx.fillStyle='black';tempCtx.fillRect(-rectWidth/2,-rectHeight/2,rectWidth,rectHeight);tempCtx.restore()}}else{displayError('Invalid coordinates for image drawing.')}}}
tempCtx.restore()}
const dataURL=tempCanvas.toDataURL('image/png');const link=document.createElement('a');link.href=dataURL;const now=new Date();const year=now.getFullYear();const month=String(now.getMonth()+1).padStart(2,'0');const day=String(now.getDate()).padStart(2,'0');const hours=String(now.getHours()).padStart(2,'0');const minutes=String(now.getMinutes()).padStart(2,'0');const filename=`captured_image_${year}${month}${day}${hours}${minutes}.png`;link.download=filename;try{link.click()}catch(error){console.error('ダウンロードに失敗しました:',error)}finally{link.remove()}});let mediaRecorder;let recordedBlobs=[];let canvasStream;onsButtonMovieExec.addEventListener('click',async()=>{const onsIconMovieExec=document.getElementById('ons-icon-movie-exec');const onsIconMovieStop=document.getElementById('ons-icon-movie-stop');if(mediaRecorder&&mediaRecorder.state==='recording'){stopRecording();onsIconMovieExec.style.display='block';onsIconMovieStop.style.display='none'}else{startRecording();onsIconMovieExec.style.display='none';onsIconMovieStop.style.display='block'}});async function startRecording(){try{recordedBlobs=[];canvasStream=canvasElement.captureStream();mediaRecorder=new MediaRecorder(canvasStream,{mimeType:'video/mp4'});mediaRecorder.ondataavailable=handleDataAvailable;mediaRecorder.onstop=handleStop;mediaRecorder.start()}catch(error){displayError(`Failed to start recording: ${error}`)}}
function handleDataAvailable(event){if(event.data&&event.data.size>0){recordedBlobs.push(event.data)}}
function handleStop(){const blob=new Blob(recordedBlobs,{type:'video/mp4'});const xhr=new XMLHttpRequest();xhr.open('GET',URL.createObjectURL(blob),!0);xhr.responseType='blob';xhr.onload=function(){if(this.status===200){const now=new Date();const year=now.getFullYear();const month=String(now.getMonth()+1).padStart(2,'0');const day=String(now.getDate()).padStart(2,'0');const hours=String(now.getHours()).padStart(2,'0');const minutes=String(now.getMinutes()).padStart(2,'0');const blob=this.response;const url=URL.createObjectURL(blob);const link=document.createElement('a');link.href=url;const filename=`recorded_video_${year}${month}${day}${hours}${minutes}.mp4`;link.download=filename;try{link.click()}catch(error){console.error('ダウンロードに失敗しました:',error)}finally{URL.revokeObjectURL(url);link.remove()}}else{console.error("ダウンロードに失敗しました:",this.statusText)}};xhr.onerror=function(){console.error("ダウンロード中にエラーが発生しました")};xhr.onprogress=function(event){if(event.lengthComputable){const percentComplete=(event.loaded/event.total)*100;console.log("ダウンロード進捗:",percentComplete,"%")}else{console.log("ダウンロード進捗: 不明")}};xhr.send();if(canvasStream){canvasStream.getTracks().forEach(track=>track.stop())}}
function stopRecording(){if(mediaRecorder&&mediaRecorder.state!=='inactive'){mediaRecorder.stop();ons.notification.toast('ダウンロードが終わるまでそのままお待ち下さい',{timeout:2000,animation:"fall"})}}
page.addEventListener("hide",async()=>{await stopCamera()})}
function お面初期化(event){const video=document.getElementById('camera-preview');const captureButton=document.getElementById('capture-button');const switchCameraButton=document.getElementById('switch-camera-button');const capturedCanvas=document.getElementById('captured-image');const bgRemovedCanvas=document.getElementById('bg-removed-canvas');const displayCanvas=document.getElementById('display-canvas');const messageDiv=document.getElementById('message');const onsButtonPushDeleteBackgroundPage=document.getElementById('ons-button-push-delete-background-page');const onsButtonImageRead=document.getElementById('ons-button-image-read');let stream;let currentCamera='environment';let selectedArea=null;let videoWidth=null;let videoHeight=null;async function startCamera(facingMode){if(stream){stream.getTracks().forEach(track=>track.stop())}
try{stream=await navigator.mediaDevices.getUserMedia({video:{facingMode}});video.srcObject=stream;video.addEventListener('loadedmetadata',()=>{videoWidth=video.videoWidth
videoHeight=video.videoHeight})}catch(error){messageDiv.innerText='カメラへのアクセス許可が必要です。'}}
async function stopCamera(){if(stream){stream.getTracks().forEach(track=>track.stop())}}
onsButtonPushDeleteBackgroundPage.addEventListener('click',async()=>{await stopCamera();const onsNavigator1=document.getElementById('ons-navigator1');onsNavigator1.pushPage('background-delete.html')});captureButton.addEventListener('click',async()=>{if(!stream){messageDiv.innerText='カメラが起動していません。';return}
const context=displayCanvas.getContext('2d');displayCanvas.width=video.videoWidth;displayCanvas.height=video.videoHeight;context.drawImage(video,0,0,displayCanvas.width,displayCanvas.height);await stopCamera();onsButtonPushDeleteBackgroundPage.style.display="block"});function handleCanvasClick(event){const rect=displayCanvas.getBoundingClientRect();const x=event.clientX-rect.left;const y=event.clientY-rect.top;if(!selectedArea){selectedArea=floodFill(displayCanvas,x,y)
displayCanvas.removeEventListener('click',handleCanvasClick);messageDiv.innerText=`選択範囲を取得しました。`}
const displayCtx=displayCanvas.getContext('2d');displayCtx.clearRect(0,0,displayCanvas.width,displayCanvas.height);displayCtx.drawImage(bgRemovedCanvas,0,0);if(selectedArea){displayCtx.fillStyle='rgba(0, 255, 0, 0.3)';selectedArea.forEach(point=>{displayCtx.fillRect(point.x,point.y,1,1)})}}
function floodFill(canvas,x,y){const ctx=canvas.getContext('2d');const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);const width=imageData.width;const height=imageData.height;const data=imageData.data;const targetColor=getPixelColor(data,x,y,width);const fillColor='rgba(255, 255, 255, 255)';const visited=new Array(width*height).fill(!1);const stack=[{x,y}];const selectedPoints=[];while(stack.length>0){const{x,y}=stack.pop();if(x<0||x>=width||y<0||y>=height){continue}
const index=y*width+x;if(visited[index]){continue}
visited[index]=!0;const currentColor=getPixelColor(data,x,y,width);if(colorsMatch(targetColor,currentColor,30)){selectedPoints.push({x,y});stack.push({x:x+1,y});stack.push({x:x-1,y});stack.push({x,y:y+1});stack.push({x,y:y-1})}}
return selectedPoints}
function getPixelColor(data,x,y,width){const index=(y*width+x)*4;return{r:data[index],g:data[index+1],b:data[index+2],a:data[index+3]}}
function colorsMatch(color1,color2,threshold){return(Math.abs(color1.r-color2.r)<=threshold&&Math.abs(color1.g-color2.g)<=threshold&&Math.abs(color1.b-color2.b)<=threshold)}
switchCameraButton.addEventListener('click',()=>{currentCamera=currentCamera==='user'?'environment':'user';startCamera(currentCamera)});onsButtonImageRead.addEventListener('click',()=>{const input=document.createElement('input');input.type='file';input.accept='image/*';input.onchange=async(e)=>{const file=e.target.files[0];if(!file)return;const image=new Image();image.onload=()=>{displayCanvas.width=image.width;displayCanvas.height=image.height;const ctx=displayCanvas.getContext('2d');ctx.drawImage(image,0,0);onsButtonPushDeleteBackgroundPage.style.display="block"};image.src=URL.createObjectURL(file)};input.click()});startCamera(currentCamera)}
function 背景削除初期化(event){let canvasOriginOmen=document.getElementById('canvas-origin-omen');const onsModalBgDelete=document.getElementById('ons-modal-bg-delete');const colorRange=document.getElementById('ons-range-bgdel-color');const backgroundDeleteButton=document.getElementById('ons-button-background-delete');const fingerSelectionButton=document.getElementById('ons-button-finger-selection');const fingerDeselectionButton=document.getElementById('ons-button-finger-deselection');const onsButtonCutout=document.getElementById('ons-button-cutout');const onsNavigator1=document.getElementById('ons-navigator1');const onsButtonBackgroundSave=document.getElementById('ons-button-background-save');const onsButtonColorRangeSelect=document.getElementById('ons-button-color-range-select');let colorRangeSelectClicked=!1;const divCutoutOptions=document.getElementById('div-cutout-options');const divBgdelColorRangeOption=document.getElementById('div-bgdel-color-range-option');const divFingerSelectionOption=document.getElementById('div-finger-selection-option');const onsRangeTouchRange=document.getElementById('ons-range-touch-range');const onsButtonCutoutExecute=document.getElementById('ons-button17');const onsButtonBgdelRedo=document.getElementById('ons-button-bgdel-redo');let imageData;let selectedPixels=new Set();let startX,startY;let clickedColor;let isRangeSelecting=!1;let isRangeDeleting=!1;let lastX,lastY;let selectionRadius=20;let touchMoveInterval=50;let lastMoveTime=0;let offscreenCanvas=null;let offscreenCtx=null;let rangeDisplayCanvas=null;let rangeDisplayCtx=null;let rangeDisplayTimeout=null;let isCutoutMode=!1;let currentMode='cutout';let cutoutRect={x:0,y:0,width:100,height:100};let draggingHandle=null;const handleSize=40;let draggingCutout=!1;let dragStartX,dragStartY;const historyStack=[];const maxHistorySize=5;function resizeCanvas(canvas,imageWidth,imageHeight){const maxSize=1024;let width=imageWidth;let height=imageHeight;if(width>maxSize||height>maxSize){if(width>height){height*=maxSize/width;width=maxSize}else{width*=maxSize/height;height=maxSize}}
canvas.width=width;canvas.height=height}
function pushHistory(){const canvas=canvasOriginOmen;const historyItem={imageData:new ImageData(new Uint8ClampedArray(imageData.data),imageData.width,imageData.height),canvasWidth:canvas.width,canvasHeight:canvas.height,cutoutRect:{...cutoutRect},selectedPixels:new Set(selectedPixels),};historyStack.push(historyItem);if(historyStack.length>maxHistorySize){historyStack.shift()}}
function init(event){canvasOriginOmen.style.display="none";const page=event.target;const omenId=page.data.omenId;historyStack.length=0;page.addEventListener('show',async()=>{canvasOriginOmen=document.getElementById('canvas-origin-omen');const rectOmen=canvasOriginOmen.getBoundingClientRect();let omen=null;let db=await openDB();try{omen=await getStoreValue(db,IMAGES_STORE_NAME,Number(omenId))}finally{if(db)await closeDB(db);}
canvasOriginOmen.style.display="block";const ctxOmen=canvasOriginOmen.getContext('2d');if(ctxOmen){const imageUrl=URL.createObjectURL(omen.blob);const img=new Image();img.src=imageUrl;img.onload=()=>{resizeCanvas(canvasOriginOmen,img.naturalWidth,img.naturalHeight)
ctxOmen.drawImage(img,0,0,canvasOriginOmen.width,canvasOriginOmen.height);imageData=ctxOmen.getImageData(0,0,canvasOriginOmen.width,canvasOriginOmen.height);URL.revokeObjectURL(imageUrl);cutoutRect.width=canvasOriginOmen.width/3;cutoutRect.height=canvasOriginOmen.height/3;cutoutRect.x=canvasOriginOmen.width/2-cutoutRect.width/2;cutoutRect.y=canvasOriginOmen.height/2-cutoutRect.height/2;switchMode('cutout')
if(!offscreenCanvas){offscreenCanvas=document.createElement('canvas');offscreenCanvas.width=canvasOriginOmen.width;offscreenCanvas.height=canvasOriginOmen.height;offscreenCtx=offscreenCanvas.getContext('2d')}
if(offscreenCtx){offscreenCtx.putImageData(imageData,0,0)}
redrawCanvas()}}else{console.error('2D描画コンテキストの取得に失敗しました。')}})}
init(event);canvasOriginOmen.addEventListener('click',handleCanvasClick);canvasOriginOmen.addEventListener('touchstart',handleTouchStart);canvasOriginOmen.addEventListener('touchmove',handleTouchMove);canvasOriginOmen.addEventListener('touchend',handleTouchEnd);colorRange.addEventListener('change',handleToleranceChange);backgroundDeleteButton.addEventListener('click',handleDeleteButtonClick);fingerSelectionButton.addEventListener('click',handleRangeSelectionButtonClick);fingerDeselectionButton.addEventListener('click',handleRangeDeleteButtonClick);onsButtonCutout.addEventListener('click',handleCutoutButtonClick);onsButtonCutoutExecute.addEventListener('click',handleCutoutExecuteButtonClick);onsButtonColorRangeSelect.addEventListener('click',handleColorRangeSelectButtonClick);onsButtonBgdelRedo.addEventListener('click',handleRedoButtonClick);onsRangeTouchRange.addEventListener('change',handleTouchRangeChange);function handleCanvasClick(event){if(!imageData)return;if(currentMode==='colorRange'){const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;startX=(event.clientX-rect.left)*scaleX;startY=(event.clientY-rect.top)*scaleY;clickedColor=getPixelColor(imageData,startX,startY);if(clickedColor){selectedPixels.clear();const newPixels=selectConnectedPixels(imageData,startX,startY,clickedColor);newPixels.forEach(pixel=>{const key=`${pixel.x},${pixel.y}`;selectedPixels.add(key)});redrawCanvasWithSelection()}}else if(currentMode==='fingerSelection'||currentMode==='fingerDeselection'){const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;startX=(event.clientX-rect.left)*scaleX;startY=(event.clientY-rect.top)*scaleY;clickedColor=getPixelColor(imageData,startX,startY);if(clickedColor){applySelection(startX,startY)}}}
function handleTouchStart(event){if(!imageData)return;if(currentMode==='cutout'){const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;const touch=event.touches[0];const touchX=(touch.clientX-rect.left)*scaleX;const touchY=(touch.clientY-rect.top)*scaleY;handleCutoutTouchStart(event,touchX,touchY)
return}
if(currentMode==='colorRange'){const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;const touch=event.touches[0];const touchX=(touch.clientX-rect.left)*scaleX;const touchY=(touch.clientY-rect.top)*scaleY;startX=touchX;startY=touchY;clickedColor=getPixelColor(imageData,startX,startY);if(clickedColor){selectedPixels.clear();const newPixels=selectConnectedPixels(imageData,startX,startY,clickedColor);newPixels.forEach(pixel=>{const key=`${pixel.x},${pixel.y}`;selectedPixels.add(key)});redrawCanvasWithSelection()}}else if(currentMode==='fingerSelection'||currentMode==='fingerDeselection'){const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;const touch=event.touches[0];const touchX=(touch.clientX-rect.left)*scaleX;const touchY=(touch.clientY-rect.top)*scaleY;startX=touchX;startY=touchY;lastX=startX;lastY=startY;clickedColor=getPixelColor(imageData,startX,startY);if(clickedColor&&(isRangeSelecting||isRangeDeleting)){event.preventDefault()}
if(clickedColor&&!(isRangeSelecting||isRangeDeleting)){if(!(isRangeSelecting||isRangeDeleting)){selectedPixels.clear()}
applySelection(startX,startY)}}}
function handleTouchMove(event){if(!imageData){return}
if(currentMode==='cutout'){handleCutoutTouchMove(event)
return}
if(currentMode==='fingerSelection'||currentMode==='fingerDeselection'){if(!(isRangeSelecting||isRangeDeleting)){return}
event.preventDefault();const now=Date.now();if(now-lastMoveTime<touchMoveInterval){return}
lastMoveTime=now;const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;const touch=event.touches[0];const currentX=(touch.clientX-rect.left)*scaleX;const currentY=(touch.clientY-rect.top)*scaleY;const pixelsToAdd=[];const step=5;if(lastX&&lastY){const dx=currentX-lastX;const dy=currentY-lastY;const distance=Math.sqrt(dx*dx+dy*dy);const steps=Math.ceil(distance/step);for(let i=0;i<=steps;i++){const x=lastX+dx*i/steps;const y=lastY+dy*i/steps;pixelsToAdd.push(...selectPixelsInRadius(imageData,x,y,selectionRadius,isRangeSelecting?null:null))}}else{pixelsToAdd.push(...selectPixelsInRadius(imageData,currentX,currentY,selectionRadius,isRangeSelecting?null:null))}
pixelsToAdd.forEach(pixel=>{const key=`${pixel.x},${pixel.y}`;if(isRangeDeleting){selectedPixels.delete(key)}else{selectedPixels.add(key)}});requestAnimationFrame(()=>{redrawCanvasWithSelection()});lastX=currentX;lastY=currentY}}
function handleTouchEnd(event){if(currentMode==='cutout'){handleCutoutTouchEnd(event)}}
function handleTouchRangeChange(){selectionRadius=parseInt(onsRangeTouchRange.value);showRangePreview(startX,startY)}
function handleToleranceChange(){if(!(currentMode==='colorRange'||!imageData||!clickedColor))return;const newPixels=selectConnectedPixels(imageData,startX,startY,clickedColor);if(!(isRangeSelecting||isRangeDeleting)){selectedPixels.clear()}
newPixels.forEach(pixel=>{const key=`${pixel.x},${pixel.y}`;if(isRangeDeleting){selectedPixels.delete(key)}else{selectedPixels.add(key)}});redrawCanvasWithSelection()}
function switchMode(mode){onsButtonCutout.classList.remove('selected');onsButtonColorRangeSelect.classList.remove('selected');fingerSelectionButton.classList.remove('selected');fingerDeselectionButton.classList.remove('selected');divCutoutOptions.style.display='none';divBgdelColorRangeOption.style.display='none';divFingerSelectionOption.style.display='none';currentMode=mode;switch(mode){case 'cutout':onsButtonCutout.classList.add('selected');divCutoutOptions.style.display='flex';isCutoutMode=!0;break;case 'colorRange':onsButtonColorRangeSelect.classList.add('selected');divBgdelColorRangeOption.style.display='flex';isCutoutMode=!1;isRangeSelecting=!1;isRangeDeleting=!1;break;case 'fingerSelection':fingerSelectionButton.classList.add('selected');divFingerSelectionOption.style.display='flex';isCutoutMode=!1;isRangeSelecting=!0;isRangeDeleting=!1;break;case 'fingerDeselection':fingerDeselectionButton.classList.add('selected');divFingerSelectionOption.style.display='flex';isCutoutMode=!1;isRangeSelecting=!1;isRangeDeleting=!0;break;case null:isCutoutMode=!1;isRangeSelecting=!1;isRangeDeleting=!1;break}
redrawCanvas()}
function handleRangeSelectionButtonClick(){switchMode('fingerSelection');showRangePreview(startX,startY)}
function handleRangeDeleteButtonClick(){switchMode('fingerDeselection');showRangePreview(startX,startY)}
function handleMovePhotoButtonClick(){const photoDataUrl=canvasOriginOmen.toDataURL('image/png');onsNavigator1.resetToPage('photo.html',{data:{photo:photoDataUrl,},})}
function handleCutoutButtonClick(){switchMode('cutout');isCutoutMode=!0;redrawCanvas()}
function handleCutoutExecuteButtonClick(){if(isCutoutMode){cutoutImage()}}
function handleColorRangeSelectButtonClick(){if(currentMode==='colorRange'){if(colorRangeSelectClicked){selectedPixels.clear();redrawCanvasWithSelection();colorRangeSelectClicked=!1}else{switchMode('colorRange');colorRangeSelectClicked=!0}}else{switchMode('colorRange');colorRangeSelectClicked=!0}}
function getPixelColor(imageData,x,y){const index=(Math.round(y)*imageData.width+Math.round(x))*4;if(index<0||index>=imageData.data.length){return null}
return{r:imageData.data[index],g:imageData.data[index+1],b:imageData.data[index+2],a:imageData.data[index+3]}}
function colorsMatch(color1,color2,tolerance){if(!color1||!color2)return!1;return(Math.abs(color1.r-color2.r)<=tolerance&&Math.abs(color1.g-color2.g)<=tolerance&&Math.abs(color1.b-color2.b)<=tolerance)}
function selectConnectedPixels(imageData,startX,startY,targetColor){const width=imageData.width;const height=imageData.height;const visited=new Array(width*height).fill(!1);const selected=[];const queue=[{x:Math.round(startX),y:Math.round(startY)}];const tolerance=parseInt(colorRange.value);while(queue.length>0){const{x,y}=queue.shift();const index=y*width+x;if(x<0||x>=width||y<0||y>=height||visited[index]){continue}
visited[index]=!0;const pixelColor=getPixelColor(imageData,x,y);if(pixelColor&&colorsMatch(pixelColor,targetColor,tolerance)){selected.push({x,y});queue.push({x:x+1,y:y});queue.push({x:x-1,y:y});queue.push({x:x,y:y+1});queue.push({x:x,y:y-1})}}
return selected}
function selectPixelsInRadius(imageData,centerX,centerY,radius,targetColor){const width=imageData.width;const height=imageData.height;const selected=[];for(let y=Math.max(0,Math.round(centerY-radius));y<=Math.min(height-1,Math.round(centerY+radius));y++){for(let x=Math.max(0,Math.round(centerX-radius));x<=Math.min(width-1,Math.round(centerX+radius));x++){const distance=Math.sqrt((x-centerX)**2+(y-centerY)**2);if(distance<=radius){if(targetColor==null||colorsMatch(getPixelColor(imageData,x,y),targetColor,parseInt(colorRange.value))){selected.push({x,y})}else if(targetColor==null){selected.push({x,y})}}}}
return selected}
function applySelection(centerX,centerY){if(!(currentMode==='fingerSelection'||currentMode==='fingerDeselection'))return;if(!imageData)return;const pixelsToAdd=selectPixelsInRadius(imageData,centerX,centerY,selectionRadius,isRangeSelecting?null:null);pixelsToAdd.forEach(pixel=>{const key=`${pixel.x},${pixel.y}`;if(isRangeDeleting){selectedPixels.delete(key)}else{selectedPixels.add(key)}});redrawCanvasWithSelection();showRangePreview(centerX,centerY)}
function showRangePreview(centerX,centerY){function rangeDisplayRemove(){if(rangeDisplayCanvas){rangeDisplayCtx.remove();rangeDisplayCanvas.removea();rangeDisplayCanvas=null;rangeDisplayCtx=null}}
if(!(currentMode==='fingerSelection'||currentMode==='fingerDeselection')){if(rangeDisplayTimeout){clearTimeout(rangeDisplayTimeout);rangeDisplayTimeout=null}
redrawCanvas();rangeDisplayRemove();return}
if(!imageData)return;rangeDisplayRemove();if(rangeDisplayTimeout){clearTimeout(rangeDisplayTimeout);rangeDisplayTimeout=null;return}
rangeDisplayCanvas=document.createElement('canvas');rangeDisplayCanvas.width=canvasOriginOmen.getBoundingClientRect().width;rangeDisplayCanvas.height=canvasOriginOmen.getBoundingClientRect().height;rangeDisplayCanvas.style.position='absolute';rangeDisplayCanvas.style.top=canvasOriginOmen.offsetTop+'px';rangeDisplayCanvas.style.left=canvasOriginOmen.offsetLeft+'px';rangeDisplayCanvas.style.pointerEvents='none';rangeDisplayCanvas.style.zIndex=10;canvasOriginOmen.parentNode.appendChild(rangeDisplayCanvas);const pWidth=rangeDisplayCanvas.width/canvasOriginOmen.width;rangeDisplayCtx=rangeDisplayCanvas.getContext('2d');if(!rangeDisplayCtx)return;rangeDisplayCtx.fillStyle='rgba(128, 128, 128, 0.5)';rangeDisplayCtx.fillRect(0,0,rangeDisplayCanvas.width,rangeDisplayCanvas.height);rangeDisplayCtx.beginPath();rangeDisplayCtx.arc(rangeDisplayCanvas.clientWidth/2,rangeDisplayCanvas.clientHeight/2,selectionRadius*pWidth,0,2*Math.PI);rangeDisplayCtx.fillStyle='white';rangeDisplayCtx.fill();rangeDisplayTimeout=setTimeout(()=>{redrawCanvas();if(rangeDisplayCanvas){canvasOriginOmen.parentNode.removeChild(rangeDisplayCanvas);rangeDisplayCanvas=null;rangeDisplayCtx=null}
rangeDisplayTimeout=null},1000)}
function redrawCanvas(){const ctxOmen=canvasOriginOmen.getContext('2d');if(!ctxOmen)return;if(offscreenCtx){ctxOmen.clearRect(0,0,canvasOriginOmen.width,canvasOriginOmen.height);ctxOmen.drawImage(offscreenCanvas,0,0)}
if(currentMode==='cutout'){drawCutoutRect(ctxOmen,!0)}}
function redrawCanvasWithSelection(){try{const ctxOmen=canvasOriginOmen.getContext('2d');if(!ctxOmen){return}
if(offscreenCtx){offscreenCtx.putImageData(imageData,0,0);offscreenCtx.fillStyle='rgba(0, 255, 0, 0.5)';selectedPixels.forEach(key=>{const[x,y]=key.split(',').map(Number);offscreenCtx.beginPath();offscreenCtx.arc(x,y,1,0,2*Math.PI);offscreenCtx.fill()});ctxOmen.clearRect(0,0,canvasOriginOmen.width,canvasOriginOmen.height);ctxOmen.drawImage(offscreenCanvas,0,0)}
if(currentMode==='cutout'){drawCutoutRect(ctxOmen,!0)}}catch(e){throw e}}
async function handleDeleteButtonClick(){if(selectedPixels.size===0){return}
pushHistory();await onsModalBgDelete.show();await new Promise((resolve)=>{setTimeout(()=>{const ctxOmen=canvasOriginOmen.getContext('2d');if(!ctxOmen){resolve();return}
selectedPixels.forEach(key=>{const[x,y]=key.split(',').map(Number);const index=(y*imageData.width+x)*4;imageData.data[index+3]=0});ctxOmen.putImageData(imageData,0,0);if(offscreenCtx)
offscreenCtx.putImageData(imageData,0,0);selectedPixels.clear();resolve()},0)});await onsModalBgDelete.hide();redrawCanvas()}
async function handleRedoButtonClick(){if(historyStack.length===0){return}
const historyItem=historyStack.pop();imageData=historyItem.imageData;cutoutRect=historyItem.cutoutRect;selectedPixels=new Set(historyItem.selectedPixels);const newCanvas=document.createElement('canvas');newCanvas.id="canvas-origin-omen";newCanvas.classList.add('canvas-omen-check');newCanvas.width=historyItem.canvasWidth;newCanvas.height=historyItem.canvasHeight;canvasOriginOmen.parentNode.insertBefore(newCanvas,canvasOriginOmen);newCanvas.addEventListener('click',handleCanvasClick);newCanvas.addEventListener('touchstart',handleTouchStart);newCanvas.addEventListener('touchmove',handleTouchMove);newCanvas.addEventListener('touchend',handleTouchEnd);canvasOriginOmen.remove();canvasOriginOmen=newCanvas;const ctxOmen=canvasOriginOmen.getContext('2d');if(!ctxOmen){return}
ctxOmen.putImageData(imageData,0,0);if(offscreenCtx){offscreenCanvas.width=canvasOriginOmen.width;offscreenCanvas.height=canvasOriginOmen.height;offscreenCtx.putImageData(imageData,0,0)}
redrawCanvas()}
function drawCutoutRect(ctx,drawHandles){if(drawHandles){ctx.strokeStyle='red';ctx.lineWidth=3;ctx.strokeRect(cutoutRect.x,cutoutRect.y,cutoutRect.width,cutoutRect.height);const handles=[{x:cutoutRect.x,y:cutoutRect.y,cursor:'nw-resize',name:"topLeft"},{x:cutoutRect.x+cutoutRect.width,y:cutoutRect.y,cursor:'ne-resize',name:"topRight"},{x:cutoutRect.x,y:cutoutRect.y+cutoutRect.height,cursor:'sw-resize',name:"bottomLeft"},{x:cutoutRect.x+cutoutRect.width,y:cutoutRect.y+cutoutRect.height,cursor:'se-resize',name:"bottomRight"},{x:cutoutRect.x+cutoutRect.width/2,y:cutoutRect.y,cursor:'n-resize',name:"topCenter"},{x:cutoutRect.x,y:cutoutRect.y+cutoutRect.height/2,cursor:'w-resize',name:"leftCenter"},{x:cutoutRect.x+cutoutRect.width,y:cutoutRect.y+cutoutRect.height/2,cursor:'e-resize',name:"rightCenter"},{x:cutoutRect.x+cutoutRect.width/2,y:cutoutRect.y+cutoutRect.height,cursor:'s-resize',name:"bottomCenter"},];ctx.fillStyle='green';handles.forEach(handle=>{ctx.fillRect(handle.x-handleSize/2,handle.y-handleSize/2,handleSize,handleSize)})}}
function getHandle(x,y){const handles=[{x:cutoutRect.x,y:cutoutRect.y,name:"topLeft"},{x:cutoutRect.x+cutoutRect.width,y:cutoutRect.y,name:"topRight"},{x:cutoutRect.x,y:cutoutRect.y+cutoutRect.height,name:"bottomLeft"},{x:cutoutRect.x+cutoutRect.width,y:cutoutRect.y+cutoutRect.height,name:"bottomRight"},{x:cutoutRect.x+cutoutRect.width/2,y:cutoutRect.y,name:"topCenter"},{x:cutoutRect.x,y:cutoutRect.y+cutoutRect.height/2,name:"leftCenter"},{x:cutoutRect.x+cutoutRect.width,y:cutoutRect.y+cutoutRect.height/2,name:"rightCenter"},{x:cutoutRect.x+cutoutRect.width/2,y:cutoutRect.y+cutoutRect.height,name:"bottomCenter"},];for(const handle of handles){const dx=x-handle.x;const dy=y-handle.y;if(Math.abs(dx)<=handleSize/2&&Math.abs(dy)<=handleSize/2){return handle.name}}
return null}
function handleCutoutTouchStart(event,touchX,touchY){if(currentMode!=='cutout')return;const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;draggingHandle=getHandle(touchX,touchY);if(draggingHandle){event.preventDefault()}else if(touchX>=cutoutRect.x&&touchX<=cutoutRect.x+cutoutRect.width&&touchY>=cutoutRect.y&&touchY<=cutoutRect.y+cutoutRect.height){draggingCutout=!0;dragStartX=touchX;dragStartY=touchY;event.preventDefault()}}
function handleCutoutTouchMove(event){if(currentMode!=='cutout'||(!draggingCutout&&!draggingHandle))return;event.preventDefault();const rect=canvasOriginOmen.getBoundingClientRect();const scaleX=canvasOriginOmen.width/rect.width;const scaleY=canvasOriginOmen.height/rect.height;const touch=event.touches[0];const touchX=(touch.clientX-rect.left)*scaleX;const touchY=(touch.clientY-rect.top)*scaleY;if(draggingCutout){const dx=touchX-dragStartX;const dy=touchY-dragStartY;cutoutRect.x+=dx;cutoutRect.y+=dy;if(cutoutRect.x<0)cutoutRect.x=0;if(cutoutRect.y<0)cutoutRect.y=0;if(cutoutRect.x+cutoutRect.width>canvasOriginOmen.width)cutoutRect.x=canvasOriginOmen.width-cutoutRect.width;if(cutoutRect.y+cutoutRect.height>canvasOriginOmen.height)cutoutRect.y=canvasOriginOmen.height-cutoutRect.height;dragStartX=touchX;dragStartY=touchY;redrawCanvas()}else if(draggingHandle){let newWidth=cutoutRect.width;let newHeight=cutoutRect.height;let newX=cutoutRect.x;let newY=cutoutRect.y;switch(draggingHandle){case "topLeft":newWidth=Math.max(handleSize*2,cutoutRect.width+cutoutRect.x-touchX);newHeight=Math.max(handleSize*2,cutoutRect.height+cutoutRect.y-touchY);newX=touchX;newY=touchY;break;case "topRight":newWidth=Math.max(handleSize*2,touchX-cutoutRect.x);newHeight=Math.max(handleSize*2,cutoutRect.height+cutoutRect.y-touchY);newY=touchY;break;case "bottomLeft":newWidth=Math.max(handleSize*2,cutoutRect.width+cutoutRect.x-touchX);newHeight=Math.max(handleSize*2,touchY-cutoutRect.y);newX=touchX;break;case "bottomRight":newWidth=Math.max(handleSize*2,touchX-cutoutRect.x);newHeight=Math.max(handleSize*2,touchY-cutoutRect.y);break;case "topCenter":newHeight=Math.max(handleSize*2,cutoutRect.height+cutoutRect.y-touchY);newY=touchY;break;case "leftCenter":newWidth=Math.max(handleSize*2,cutoutRect.width+cutoutRect.x-touchX);newX=touchX;break;case "rightCenter":newWidth=Math.max(handleSize*2,touchX-cutoutRect.x);break;case "bottomCenter":newHeight=Math.max(handleSize*2,touchY-cutoutRect.y);break}
newWidth=Math.min(newWidth,canvasOriginOmen.width-newX);newHeight=Math.min(newHeight,canvasOriginOmen.height-newY);newWidth=Math.max(newWidth,handleSize*2)
newHeight=Math.max(newHeight,handleSize*2)
cutoutRect.width=newWidth;cutoutRect.height=newHeight;cutoutRect.x=newX;cutoutRect.y=newY
if(cutoutRect.x<0)cutoutRect.x=0;if(cutoutRect.y<0)cutoutRect.y=0;redrawCanvas()}}
function handleCutoutTouchEnd(){if(draggingHandle){draggingHandle=null}
if(draggingCutout){draggingCutout=!1}}
function cutoutImage(){const ctxOmen=canvasOriginOmen.getContext('2d');if(!ctxOmen)return;pushHistory();if(offscreenCtx){offscreenCtx.putImageData(imageData,0,0)}
const cutImageData=offscreenCtx.getImageData(cutoutRect.x,cutoutRect.y,cutoutRect.width,cutoutRect.height);const newCanvas=document.createElement('canvas');newCanvas.classList.add('canvas-omen-check');resizeCanvas(newCanvas,cutImageData.width,cutImageData.height);const newCtx=newCanvas.getContext('2d');if(newCtx){newCtx.putImageData(cutImageData,0,0);canvasOriginOmen.parentNode.insertBefore(newCanvas,canvasOriginOmen);newCanvas.style.zIndex=canvasOriginOmen.style.zIndex;newCanvas.addEventListener('click',handleCanvasClick);newCanvas.addEventListener('touchstart',handleTouchStart);newCanvas.addEventListener('touchmove',handleTouchMove);newCanvas.addEventListener('touchend',handleTouchEnd);canvasOriginOmen.remove();canvasOriginOmen=newCanvas;canvasOriginOmen.id="canvas-origin-omen";imageData=newCtx.getImageData(0,0,newCanvas.width,newCanvas.height);if(offscreenCtx){offscreenCanvas.width=canvasOriginOmen.width;offscreenCanvas.height=canvasOriginOmen.height;offscreenCtx.putImageData(imageData,0,0)}}
cutoutRect.width=canvasOriginOmen.width/3;cutoutRect.height=canvasOriginOmen.height/3;cutoutRect.x=canvasOriginOmen.width/2-cutoutRect.width/2;cutoutRect.y=canvasOriginOmen.height/2-cutoutRect.height/2;isCutoutMode=!1;switchMode(null)}
onsButtonBackgroundSave.addEventListener("click",async(event)=>{const page=event.target.closest("ons-page");const omenId=page.data.omenId;let db=null;try{db=await openDB();let omen=await getStoreValue(db,IMAGES_STORE_NAME,Number(omenId));const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');canvas.width=imageData.width;canvas.height=imageData.height;ctx.putImageData(imageData,0,0);omen.blob=await new Promise((resolve)=>{canvas.toBlob(resolve,'image/png')});await putStoreValue(db,IMAGES_STORE_NAME,omen)}finally{if(db)await closeDB(db);}
onsNavigator1.popPage()})}
const DB_NAME="orega-xx-db";const DB_VERSION=1;const APP_SETTING_STORE_NAME="settings";const IMAGES_STORE_NAME="images";async function DB初期化(){let db=null;try{db=await openDB()}catch(error){alert(`DBの初期化でエラーが発生しました: ${error}`);throw error}finally{if(db)await closeDB(db);}}
async function openDB(){return new Promise((resolve,reject)=>{const request=indexedDB.open(DB_NAME,DB_VERSION);request.onerror=(event)=>{reject(event)};request.onsuccess=(event)=>{resolve(event.target.result)};request.onupgradeneeded=(event)=>{const db=event.target.result;if(DB_VERSION===1){if(!db.objectStoreNames.contains(APP_SETTING_STORE_NAME)){db.createObjectStore(APP_SETTING_STORE_NAME,{keyPath:"key"})}
if(!db.objectStoreNames.contains(IMAGES_STORE_NAME)){db.createObjectStore(IMAGES_STORE_NAME,{keyPath:"id",autoIncrement:!0})}}}})}
async function putStoreValue(db,storeName,value){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readwrite');const store=tx.objectStore(storeName);const request=store.put(value);request.onsuccess=(event)=>{resolve(event.target.result)};request.onerror=(event)=>{reject(event.target.error)};tx.oncomplete=()=>{};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function getStoreValue(db,storeName,key){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readonly');const store=tx.objectStore(storeName);const request=store.get(key);request.onsuccess=(event)=>{resolve(event.target.result)};request.onerror=(event)=>{reject(event.target.error)};tx.oncomplete=()=>{};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function getAllStoreValue(db,storeName){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readonly');const store=tx.objectStore(storeName);const request=store.getAll();request.onsuccess=(event)=>{resolve(event.target.result)};request.onerror=(event)=>{reject(event.target.error)};tx.oncomplete=()=>{};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function deleteStoreValue(db,storeName,key){return new Promise((resolve,reject)=>{const tx=db.transaction(storeName,'readwrite');const store=tx.objectStore(storeName);const request=store.delete(key);request.onsuccess=(event)=>{resolve(event.target.result)};tx.onerror=(event)=>{reject(event.target.error)};tx.onabort=(event)=>{reject(new Error(`Transaction aborted: ${event.target.error?.message || 'Unknown reason'}`))}})}
async function deleteIndexedDB(dbName){return new Promise((resolve,reject)=>{const request=indexedDB.deleteDatabase(dbName);request.onsuccess=()=>{console.log("IndexedDB deleted successfully.");resolve()};request.onerror=(event)=>{console.error("Error deleting IndexedDB:",event.target.error);reject(event.target.error)}})}
async function closeDB(db){return new Promise((resolve,reject)=>{db.close();resolve()})}
async function トップページ初期化(event){const page=event.target;const onsNavigator1=document.getElementById('ons-navigator1');const onsButtonOmenKaburu=document.getElementById('ons-button-omen-kaburu');const onsButtonOmenKanri=document.getElementById('ons-button-omen-kanri');const onsCarouselOmen=document.getElementById('ons-carousel-omen');const templateCarouselItem=document.getElementById('template-carousel-item');const onsDialogSetting=document.getElementById('ons-dialog-setting');const onsButtonAppDelete=document.getElementById('ons-button-app-delete');const onsButtonSettingGear=document.getElementById('ons-button-setting-gear');let db=null;try{db=await openDB();const init=await getStoreValue(db,APP_SETTING_STORE_NAME,"initialized");if(!init){const imageUrls=['images/omen-sample2.png','images/omen-sample1.png'];for(const imageUrl of imageUrls){try{const response=await fetch(imageUrl);const blob=await response.blob();const imageData={blob:blob};await putStoreValue(db,IMAGES_STORE_NAME,imageData)}catch(error){console.error(`画像の読み込みに失敗しました: ${error}`);ons.notification.alert("初期画像の読み込みに失敗しました。アプリを閉じてから起動してください。");return}}
await putStoreValue(db,APP_SETTING_STORE_NAME,{key:'initialized',value:!0})}}finally{if(db)await closeDB(db);}
async function showOmen(){const items=onsCarouselOmen.querySelectorAll("ons-carousel-item");for(const item of items){item.remove()}
db=null;try{db=await openDB();const images=await getAllStoreValue(db,IMAGES_STORE_NAME);for(const image of images){const clonedItem=templateCarouselItem.content.cloneNode(!0);const imgElement=clonedItem.querySelector('.omen-carousel-image');imgElement.src=URL.createObjectURL(image.blob);onsCarouselOmen.appendChild(clonedItem)}}finally{if(db)await closeDB(db);}}
onsButtonOmenKaburu.addEventListener('click',()=>{debugger
const currentCarouselItemIndex=onsCarouselOmen.activeIndex||0;const currentCarouselItem=onsCarouselOmen.querySelectorAll('ons-carousel-item')[currentCarouselItemIndex];const selectedImage=currentCarouselItem.querySelector('img');if(selectedImage){const canvas=document.createElement('canvas');const ctx=canvas.getContext('2d');canvas.width=selectedImage.naturalWidth;canvas.height=selectedImage.naturalHeight;ctx.drawImage(selectedImage,0,0);let mimeType='image/png';if(selectedImage.src.startsWith('data:image/')){mimeType=selectedImage.src.split(';')[0].split(':')[1]}else{const imageExtension=selectedImage.src.split('.').pop().toLowerCase();if(imageExtension==='jpg'||imageExtension==='jpeg'){mimeType='image/jpeg'}else if(imageExtension==='webp'){mimeType='image/webp'}else if(imageExtension==='gif'){mimeType='image/gif'}else if(imageExtension==='png'){mimeType='image/png'}}
const photoDataUrl=canvas.toDataURL(mimeType);onsNavigator1.pushPage('photo.html',{data:{photo:photoDataUrl}})}});onsButtonOmenKanri.addEventListener('click',()=>{onsNavigator1.pushPage('omen-kanri.html')});onsButtonSettingGear.addEventListener('click',()=>{onsDialogSetting.show()});onsButtonAppDelete.addEventListener('click',async()=>{const ret=await ons.notification.confirm("保存されているお面のデータがすべて削除されます。問題ありませんか？",{title:"確認",buttonLabels:["はい","いいえ"],});if(ret===0){await deleteIndexedDB(DB_NAME);await ons.notification.alert("削除しました。このままアプリを終了してください。",{title:"メッセージ"});onsDialogSetting.hide()}});page.addEventListener("show",showOmen);showOmen()}
function ヒストリー追加(event){try{history.pushState({},'','')}catch(e){console.log(e)}}
function ヒストリー消去(event){window.history.back()}
function バックボタン処理(event){const onsNavigator1=document.getElementById('ons-navigator1');onsNavigator1.popPage()}
function お面の管理初期化(event){const page=event.target;const onsButtonOmenAddImage=document.getElementById('ons-button-omen-add-image');const templateOmenKanriCard=document.getElementById('template-omen-kanri-card');const omenKanriList=document.getElementById('omen-kanri-list');const onsNavigator1=document.getElementById('ons-navigator1');async function showOmenList(){omenKanriList.textContent="";let images=[];let db=null;try{db=await openDB();images=await getAllStoreValue(db,IMAGES_STORE_NAME)}finally{if(db)await closeDB(db);}
for(const image of images){const clonedItem=templateOmenKanriCard.content.cloneNode(!0);const clonedCard=clonedItem.querySelector('ons-card');const omenKanriEditElement=clonedItem.querySelector('.omen-kanri-edit');const omenKanriDeleteElement=clonedItem.querySelector('.omen-kanri-delete');clonedCard.dataset.omenId=image.id;const omenKanriImgElement=clonedItem.querySelector('.omen-kanri-img');omenKanriImgElement.src=URL.createObjectURL(image.blob);omenKanriDeleteElement.addEventListener('click',async(event)=>{const targetCard=event.target.closest("ons-card");const ret=await ons.notification.confirm('本当に削除しますか？',{title:"確認",buttonLabels:["はい","いいえ"]})
if(ret===0){db=await openDB();try{await deleteStoreValue(db,IMAGES_STORE_NAME,Number(targetCard.dataset.omenId));ons.notification.alert("削除しました",{title:"メッセージ"})}finally{if(db)await closeDB(db);}
showOmenList()}});omenKanriEditElement.addEventListener("click",()=>{onsNavigator1.pushPage("background-delete.html",{data:{omenId:image.id}})});const omenKanriList=document.getElementById('omen-kanri-list');omenKanriList.appendChild(clonedItem)}}
onsButtonOmenAddImage.addEventListener("click",async()=>{const input=document.createElement('input');input.type='file';input.accept='image/*';input.addEventListener('change',async(event)=>{const file=event.target.files[0];if(file){const blob=new Blob([file],{type:file.type});let db=null;try{db=await openDB();await putStoreValue(db,IMAGES_STORE_NAME,{blob:blob});ons.notification.alert('画像を追加しました',{title:'メッセージ'})}finally{if(db)await closeDB(db);}
showOmenList()}});input.click()});page.addEventListener('show',showOmenList)}
document.addEventListener('DOMContentLoaded',DB初期化);window.addEventListener('popstate',バックボタン処理);let onsnavigator1_element=document.querySelector('#ons-navigator1');if(onsnavigator1_element){onsnavigator1_element.addEventListener('prepush',ヒストリー追加);onsnavigator1_element.addEventListener('prepop',ヒストリー消去)}
document.addEventListener('init',(event)=>{let page=event.target;if(page.id==='ons-page2'){お面初期化(event)}});document.addEventListener('init',(event)=>{let page=event.target;if(page.id==='ons-page3'){背景削除初期化(event)}});document.addEventListener('init',(event)=>{let page=event.target;if(page.id==='ons-page-photo'){撮影ページ初期化(event)}});document.addEventListener('init',(event)=>{let page=event.target;if(page.id==='ons-page4'){トップページ初期化(event)}});document.addEventListener('init',(event)=>{let page=event.target;if(page.id==='ons-page-omen-kanri'){お面の管理初期化(event)}})